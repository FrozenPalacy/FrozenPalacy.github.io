[{"content":"IAI727 202310月赛丙组T5 先修课程\n题目大意 一个有向图，有$n$个节点$m$条边，输入$n$和$m$和每条边的起点和终点。\n判断有向图的所有点是否都能在拓扑序中。能就输出Valid，否则输出Invalid。\n题解 看到原题有\n其中的第$i$条约束要求在学习第$y_i$ 门课程之前，必须先修完第$x_i$门课程。\n这样的优雅表述，判断可以用拓扑排序来解。\n拓扑排序是通过按照某个拓扑序的方法来遍历一张有向图。举个例子：\n这是一张有5个结点的有向图。遵循的原则是：\n当某个点的所有前驱节点都已被遍历时，这个点就可以被遍历。\n（可能不是前驱，但意思等同于前驱）\n例如，这张图中，1没有前驱节点。可以先遍历1，随后3没有别的前驱了，需要遍历3。此时点2的所有前驱都被遍历，可以遍历点2。此时4的所有前驱都被遍历，可以遍历点4。此时，5的前驱即3和4都被遍历，可以遍历5。本图的一种拓扑序即为1 3 2 4 5。\n一张图可能有多个拓扑序。例如将本图中1到3的边删掉，就可以有1 3 2 4 5和3 1 2 4 5两个拓扑序。\n回到本题。题目说的矛盾即为存在一个点无法被拓扑序遍历到。\n例如样例1的图，简单画一下就可以发现它没有任何一个节点是没有前驱节点的，拓扑序无从建起，自然是Invalid。\n那么推广一下，思路出来了：\n为图进行一次按照拓扑序的遍历，看看是否能够遍历到每一个点。如果不能遍历到每一个点，就是存在矛盾，输出Invalid。否则Valid。\n实现 用一个邻接表来存储有向图。\nconst int MAXN=200005; vector\u0026lt;int\u0026gt; v[MAXN]; 首先输入$n$,$m$的值，并建图。\n注意到，判断一个点是否有前驱，可以通过存储其入度的数量来简单判断。如果它的入度数量为0，那么它没有前驱。所以定义一个数组来存储某个点的入度数量。\ncin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; v[a].push_back(b); d[b]++;//存入度数量的数组 int类型 } 看到刚才举的例子，当点1被遍历后，它下一个点可以选择遍历点2或者点3。但是点2还有别的前驱，点3没有了。所以遍历点3。\n那么这样，就可以通过bfs，将遍历到的点指向的点的入度都减去1，即”消去一条边“。当指向的点入度变成0的时候，入队，对它bfs。\nfor(int i=1;i\u0026lt;=n;i++)if(!d[i])q.push(i);//初始化 找拓扑序起点 while(!q.empty()) { int x=q.front();q.pop();//bfs cnt++;//记录遍历了多少个点 for(int i=0;i\u0026lt;v[x].size();i++) { int final=v[x][i]; d[final]--;//消边 if(!d[final])q.push(final);//如果指向的点没有别的前驱了就入队 } } 按照思路，我们统计一下遍历了多少个点，如果$cnt==n$，那么Valid。否则Invalid。\ncout\u0026lt;\u0026lt;((cnt!=n)?\u0026#34;Invalid\u0026#34;:\u0026#34;Valid\u0026#34;); AC Code\n//20231106 @ iai.sh.cn #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef long long ll; const int MAXN=200005; int n,m,d[MAXN],cnt; vector\u0026lt;int\u0026gt; v[MAXN]; queue\u0026lt;int\u0026gt; q; int main() { ios::sync_with_stdio(0);cin.tie(0);cout.tie(0); // freopen(\u0026#34;1.txt\u0026#34;,\u0026#34;r\u0026#34;,stdin); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;m; for(int i=1;i\u0026lt;=m;i++) { int a,b; cin\u0026gt;\u0026gt;a\u0026gt;\u0026gt;b; v[a].push_back(b); d[b]++; } for(int i=1;i\u0026lt;=n;i++)if(!d[i])q.push(i); while(!q.empty()) { int x=q.front();q.pop(); cnt++; for(int i=0;i\u0026lt;v[x].size();i++) { int final=v[x][i]; d[final]--; if(!d[final])q.push(final); } } cout\u0026lt;\u0026lt;((cnt!=n)?\u0026#34;Invalid\u0026#34;:\u0026#34;Valid\u0026#34;); return 0; } ","date":"2023-11-06T22:26:37+08:00","permalink":"http://xfrozenx.top/post/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","title":"拓扑排序"},{"content":"#OI - 时间复杂度\n单循环\neg Code\nvoid fun(int n) { int i = 0; while (i * i * i \u0026lt;= n) i++; } 次数 $0$ 1 2 条件（iii） 0 1 2^3 etc.\n规律：当执行至第$k$次时，条件数字即为$k^3$.\n设$k^3\\leq n$。令$n\\rightarrow\\infty$，则$k^3=n$.\n则$k=\\sqrt[3]{n}$.此算法的时间复杂度即为$O(\\sqrt{n})$.（略去了常数因子）\n例2\nvoid fun(int n) { int i = 1; while (i \u0026lt;= n) i *= 2; } 次数 $0$ 1 2 条件（i） 1 2 2^2 规律：同上，$2^k=n$，$k=\\log_2n$.\n$\\therefore O(\\log n)$.\n例3\nvoid fun(int n) { int x = 0; while (n \u0026gt;= (x + 1) * (x + 1)) x += 1; } 条件为$(x+1)^2$，同样列表可知$(k+1)^2=n$，$k=\\sqrt{n}-1$.\n在时间复杂度中，常数项一般略去。\n$\\therefore O(\\sqrt{n})$.\n多层循环\n情况1 - 外层不影响内层\nvoid fun(int n) { int count = 0; for (int k = 1; k \u0026lt;= n; k *= 2) for (int j = 1; j \u0026lt;= n; j++) count++; } 可看作是两个单循环。\n先计算外循环。同理列表，\n次数 0 1 2 条件 1 2 4 故$2^k=n$，$k=\\log_2n$.\n内循环同理列表，$O(n)$.\n整体算法的时间复杂度为内外循环相乘，$n\\log_2n$.\n此处注意，由于换底公式，$\\log_an$与$\\log_bn$仅有一个因子不同，故在计算时间复杂度时不论对数的底。\n算法的时间复杂度为$O(n\\log n)$.\n情况2 - 外层影响内层\n即内层的条件与外层有关。\nvoid fun(int n) { int m = 0, i, j; for (i = 1; i \u0026lt;= n; i++) for (int j = 1; j \u0026lt;= i * 2; j++) m++; } 首先介绍一些公式：\n$$ \\sum_{i=1}^ni=\\frac{n(n+1)}{2}$$ $$ \\sum_{i=1}^ni^2=\\frac{n(n+1)(2n+1)}{6} $$\n特殊地，对于常数列求和：\n$$ \\sum_{i=1}^nk=kn $$\n那么对于此题，可知：\n外层循环的循环次数为$\\sum_{i=1}^n$，内层为$\\sum_{j=1}^{2i}1$。\n两式相乘，得到\n$$ \\sum_{i=1}^n\\sum_{j=1}^{2i}1=\\sum_{i=1}^n2i $$$$ 由公式1，原式=\\frac{n(n+1)}{2} $$\n故总共执行$\\frac{n^2+n}{2}$次。时间复杂度$O(n^2)$.（取最高次）\n在计算好语句块的执行次数后，需要注意在整理成时间复杂度时略去常数因子，如$\\log_2n$的底、$\\sqrt[3]n$的根指数等，写成$O(\\log n)$、$O(\\sqrt n)$.\n","date":"2023-09-12T22:02:25+08:00","permalink":"http://xfrozenx.top/post/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"时间复杂度"},{"content":" 函数\n一组一起执行一个任务的语句。\n返回类型 函数名(参数类型1 参数名1,..,参数类型n 参数名n) { //函数体 return 返回值 } //对于void函数，不存在返回值。 递归函数\n自己调用自己的函数\neg. 阶乘\nint fact(int n) { if (n == 0) return 1; else return n * fact(n - 1); } 递归的一般形式\nint find(arg1, arg2...) { if (特殊情况 or 边界条件) { // 处理 return xxx; } // 递归操作； return xxx; } // 对于void函数，直接使用return; step型递归\n例题：天平平衡问题\n题目描述 你有n个重量不同的砝码和一个天平，每个砝码可以放在左盘或者右盘或者不放。砝码重量为 $w_1,w_2,\u0026hellip;,w_n$ ，问有多少种放置砝码的方式，使得天平平衡?（两边都不放任何砝码也算一种平衡方式）\n输入格式 第 1 行，1 个正整数 $n$ 。 第 2 行，$n$ 个正整数 $w_1,w_2,\u0026hellip;w_n$，以空格分隔。\n输出格式 输出使得天平平衡的放置方案数。\n输入输出样例 输入数据 1 5 1 2 3 5 6 输出数据 1 13 数据范围 对于 $100%$ 的数据，满足 $1\\leq n\\leq13,1\\leq w_i\\leq100$。\nAC Code\n// 20230712 @ Hydro.ac #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n, w[20], ans; void find(int p, int wl, int wr) { if (p \u0026gt; n) // 边界条件：如果已经枚举到超过n了 { if (wl == wr) { ans++; // 答案++ } return; } // 三种情况分别枚举递归 find(p + 1, wl + w[p], wr); find(p + 1, wl, wr + w[p]); find(p + 1, wl, wr); //这里的wl和wr也可以用全局变量写 //在调用之前要记得wl+=w[p]，调用完要减回去。称作回溯操作。 } int main() { cin \u0026gt;\u0026gt; n; for (int i = 1; i \u0026lt;= n; i++) { cin \u0026gt;\u0026gt; w[i]; } find(1, 0, 0); cout \u0026lt;\u0026lt; ans; return 0; } 深度优先搜索 DFS\n听起来好高大上 利用递归函数，枚举所有的情况找到答案。 剪枝 对于中途发现已经不可能的情况直接跳出这一部分搜索。 例题：P2089 烤鸡\n烤鸡 题目背景 猪猪 Hanke 得到了一只鸡。\n题目描述 猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 10 种配料（芥末、孜然等），每种配料可以放 1 到 3 克，任意烤鸡的美味程度为所有配料质量之和。\n现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。\n输入格式 一个正整数 $n$，表示美味程度。\n输出格式 第一行，方案总数。\n第二行至结束，10 个数，表示每种配料所放的质量，按字典序排列。\n如果没有符合要求的方法，就只要在第一行输出一个 0。\n样例 #1 样例输入 #1 11 样例输出 #1 10 1 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 2 1 1 1 1 1 1 1 1 1 提示 对于 100% 的数据，$n \\leq 5000$。\nAC Code\n//20230712 @ Hydro.ac //不写注释了。我自己都不想再看一遍这代码。 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,counter=0,u[10000][15],u2[15]; void dfs(int p,int sum) { if(p==10) { if(sum==n) { counter++; for(int i=0;i\u0026lt;10;i++) { u[counter][i]=u2[i]; } } return; } for(int i=1;i\u0026lt;=3;i++) { u2[p]=i; dfs(p+1,sum+i); } return; } int main() { cin\u0026gt;\u0026gt;n; dfs(0,0); cout\u0026lt;\u0026lt;counter\u0026lt;\u0026lt;endl; for(int i=1;i\u0026lt;=counter;i++) { for(int j=0;j\u0026lt;10;j++) cout\u0026lt;\u0026lt;u[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-07-13T17:08:22+08:00","permalink":"http://xfrozenx.top/post/%E9%80%92%E5%BD%92%E6%B7%B1%E6%90%9C%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8C%96/","title":"递归、深搜及其优化"},{"content":" 质数判断\n让$i$从2枚举到$\\sqrt{N}$，若对每一个$i$$n%i\\neq0$，则是质数。否则是合数\nCode\nint n;bool prime=true; for(int i=2;i*i\u0026lt;=n;i++) if(d%i==0) { prime=false;break; } 筛法\n用于计算哪些数字是素数\n用bool型变量作为桶，记录某个数是否为素数。\n埃式筛法\n将isPrime[N]数组初始化为false，即均为质数。\nisPrime[0]=isPrime[1]=true;\n从2开始枚举，若是质数，将其所有的倍数记录为合数。\nCode\nisprime[0] = isprime[1] = true; for (int i = 2; i * i \u0026lt;= n; i++) { if (!isprime[i]) { for (int j = i * i; j \u0026lt;= n; j += i) { isprime[j] = true; } } } 线性筛法\n用每个数的最小质因数进行标记。\nCode\n（有点问题，之后补）\nGCD \u0026amp; LCM\nGCD $GCD(a,b)=GCD(b,a%b)$。（辗转相除） LCM $LCM(a,b)\\times GCD(a,b)=a\\times b$. 快速幂\n$ans=a^b%p$时，快速求ans。\nans = 1; while (b) { if (b \u0026amp; 1) { ans *= a; ans %= p; } a *= a; a %= p; b \u0026gt;\u0026gt;= 1; } cout \u0026lt;\u0026lt; ans; ","date":"2023-07-11T19:22:52+08:00","permalink":"http://xfrozenx.top/post/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/","title":"基础数论"},{"content":" 前缀和\nDef. 某数组前若干数的和\n设一数组$a$，$s[1]=a[1]$，$s[2]=a[1]+a[2]$，\n$s[n]=a[1]+a[2]+\u0026hellip;+a[n-1]+a[n]$.\n用此方法求区间$[l,r]$的和\n$$ s_{lr}=s[r]-s[l-1] $$\n相较于$for$循环求若干数的和，前缀和这一算法能将时间复杂度由$O(n)$降为$O(1)$。\n前缀和属于优化类算法。\n差分\nDef. 是这个数与前一个数的差\n设一数组$a$，则有\n$$ d[1]=a[1]\\d[2]=a[2]-a[1]\\d[3]=a[3]-a[2]\\d[n]=a[n]-a[n-1] $$\n******注意！！！$a[0]=0$.\n差分多用于对区间$[l,r]$中的每一项都进行相同的修改（加减）\n例题可见 Hydro B0409或洛谷P2367。\n对于普通的数组，使某区间内的每一项进行相同加减，需要用$for$循环，做如下操作\n$$ a[l]+=c\\a[l+1]+=c\\\u0026hellip;\u0026hellip;\\O(n) $$\n对于差分数组，只需要做\n$$ d[l]+=c\\d[r+1]-=c\\O(1) $$\n故与前缀和一样，是优化类算法。同时，差分算法是前缀和的逆运算。\n根据差分数列反求出修改后的原数列\n可使用如下代码\nfor(int i=1;i\u0026lt;=n;i++) { d[i]+=d[i-1]; cout\u0026lt;\u0026lt;d[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } 我好像也不太理解 但是先背着吧\n二维前缀和\n即针对二维的$a$数组的前缀和操作。\n偷懒直接上图。\n尺取法（Two pointers）\n无法评述。参见例题。 P1147 连续自然数和 题目描述 对一个给定的正整数 $M$，求出所有的连续的正整数段（每一段至少有两个数），这些连续的自然数段中的全部数之和为 $M$。\n例子：$1998+1999+2000+2001+2002 = 10000$，所以从 $1998$ 到 $2002$ 的一个自然数段为 $M=10000$ 的一个解。\n输入格式 包含一个整数的单独一行给出 $M$ 的值（$10 \\le M \\le 2,000,000$）。\n输出格式 每行两个正整数，给出一个满足条件的连续正整数段中的第一个数和最后一个数，两数之间用一个空格隔开，所有输出行的第一个按从小到大的升序排列，对于给定的输入数据，保证至少有一个解。\n样例 #1 样例输入 #1 10000 样例输出 #1 18 142 297 328 388 412 1998 2002 AC Code\n//20230707 @ Hydro.ac //尺取法 #include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int m,sum=0; int main() { cin\u0026gt;\u0026gt;m; for(int l=1,r=1;r\u0026lt;m;r++) { sum+=r; while(sum\u0026gt;m)//如果总和大于m { sum-=l;//在总和中删掉起点 l++; } if(sum==m) cout\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; } return 0; } ","date":"2023-07-07T18:33:08+08:00","permalink":"http://xfrozenx.top/post/%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86-%E5%B0%BA%E5%8F%96%E6%B3%95/","title":"前缀和 差分 尺取法"},{"content":" 二分查找（查找特定值）\n定义查找区间的左右端点$l$和$r$，查找区间$[l,r]$. 当$l\\leq r$时，计算中间值$mid=(l+r)/2=l+(r-l)/2$. 若$mid=k$，则找到答案 若$mid\u0026gt;k$，则设$r=mid-1$，继续搜索 若$mid\u0026lt;k$，则设$l=mid+1$，继续搜索 当$l\u0026gt;r$时，原区间$[l.r]$内不存在$k$。 模板代码： while (l \u0026lt;= r) { int mid = (l + r) / 2; if (a[mid] == b) { // 找到此数 break; } if (a[mid] \u0026gt; b) r = mid - 1; else l = mid + 1; } 二分查找（查找第一个满足条件的位置）\n初始赋值：$l$是一个不满足条件的位置，$r$是一个满足条件的位置。 当$l+1\u0026lt;r$，即$l$和$r$不相邻时，计算中间端点$mid=(l+r)/2=l+(r-l)/2$. 若$mid$满足条件，设$r=mid$，继续搜索 若$mid$不满足条件，设$l=mid$，继续搜索 当$l+1=r$时，$r$为第一个满足条件的位置。 模板代码 while (l + 1 \u0026lt; r) { int mid = (l + r) / 2; if (a[mid] \u0026gt;= k) r = mid; else l = mid; } 二分答案\n使用二分查找的思路，通过对if的条件加以修改，得到答案，即为二分查找。 ","date":"2023-07-05T18:31:21+08:00","permalink":"http://xfrozenx.top/post/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%92%8C%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/","title":"二分查找和二分答案"},{"content":" Carpet Extra Carpet Extra is an extension adding extra features to Fabric Carpet, like countless new dispenser behaviours, new ways to get resources in a renewable way and many others!\nFor its enabled dispenser behaviours it also adds a new Scarpet event that triggers when those happen, allowing you to further customize them.\nMore extensions If you\u0026rsquo;re looking for Carpet autocrafting table, it has been moved to a standalone extension you can find on its repository on Github.\nThere are also lots of other carpet extensions out there, adding countless new rules and functionality! You can find a list of them in the Carpet wiki.\nCarpet Extra Features Carpet Mod Settings accurateBlockPlacement Client can provide alternative block placement.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, SURVIVAL autoCraftingDropper Auto-crafting dropper\nIf a dropper points into a crafting table and contains a valid 3x3 crafting recipe, firing that\ndropper will cause it to craft (drop as item) that recipe.\nOverrides comparators so they indicate number of filled slots instead.\nAlso makes hoppers, droppers and dispensers input max 1 item per slot.\nType: Boolean Default value: false Allowed options: true, false Categories: CREATIVE, EXTRAS, DISPENSER betterBonemeal Bonemeal can be used to grow sugarcane, cactus and lily pads.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS, SURVIVAL blazeMeal Blaze powder fertilizes netherwart.\nVia dispenser or player right click actions.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, SURVIVAL blockStateSyncing Fixes block states in F3 debug mode not updating for some blocks.\nMay cause increased network traffic.\nWorks with cactus, sugar cane, saplings, hoppers, dispensers and droppers.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL chickenShearing Chickens can be sheared to get feathers. Beware! every time u shear a chicken, it gets damaged!\nBaby chickens can\u0026rsquo;t be sheared.\nAlso works with dispensers\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER clericsFarmWarts Clerics can warm nether farts.\nThis will also allow them to pick up wart items, as well as pathfind to soulsand.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE commandPing Enables /ping for players to get their ping.\nType: Boolean Default value: true Allowed options: true, false Categories: COMMAND, EXTRAS Additional notes: It has an accompanying command comparatorBetterItemFrames Allows Comparators to see item frames that are horizontal in front of them and on top the the block in front of them\nBehind: Allows comparators to detect item frames in the block behind them\nLenient: Allows comparators to detect any item frames within the block behind a full block\nExtended: Allows comparators to detect item frames on a full block behind the comparator\nType: ComparatorOptions Default value: vanilla Allowed options: vanilla, behind, lenient, extended Categories: FEATURE, EXTRAS, EXPERIMENTAL comparatorReadsClock Allows Comparators to read the daytime instead of the rotation of clocks in item frames.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS, EXPERIMENTAL creeperSpawningInJungleTemples Only creepers spawn in jungle temples.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS disablePlayerCollision Disables player entity collision.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, CREATIVE, EXPERIMENTAL dispenserPlacesBlocks Dispensers can place blocks.\nType: Boolean Default value: false Allowed options: true, false Categories: CREATIVE, EXTRAS, DISPENSER dispensersCarvePumpkins Dispensers containing shears can carve pumpkins.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER dispensersFeedAnimals Dispensers can feed animals if given their breeding item.\nCan also feed flowers to brown mooshrooms to give them a suspicious stew effect\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL, FEATURE, DISPENSER dispensersFillMinecarts Minecarts can be filled with hoppers, chests, tnt and furnace.\nType: Boolean Default value: false Allowed options: true, false Categories: EXPERIMENTAL, FEATURE, EXTRAS, DISPENSER dispensersMilkAnimals Dispensers with empty buckets can milk cows/mooshrooms/goats, and get mushroom/suspicious stew from mooshrooms with bowls.\nType: Boolean Default value: false Allowed options: true, false Categories: EXPERIMENTAL, EXTRAS, FEATURE, DISPENSER dispensersPlaceBoatsOnIce Dispensers can place boats on ice\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER dispensersPlayRecords Dispensers can play records if there\u0026rsquo;s a jukebox in front of them.\nIf a record already exists in the jukebox, it gets placed back in the dispenser.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER dispensersPotPlants Dispensers can put flowers in flower pots\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER dispensersStripBlocks Dispensers with axes can strip blocks\nCan strip logs, remove oxidation, and remove wax\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER dispensersTillSoil Dispensers with hoes can till soil.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER dispensersToggleThings Dispensers containing a stick can toggle/activate things.\nWorks with buttons, redstone, noteblocks, comparators, repeaters,\ndaylight detectors, etc.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL, FEATURE, DISPENSER dispensersUseCauldrons Dispensers can empty/fill cauldrons with buckets or bottles, and undye leather armor/shulker boxes/banners\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER doubleRetraction Re-adds 1.8 double retraction to pistons.\nGives pistons the ability to double retract without side effects.\nFixes MC-88959.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL dragonEggBedrockBreaking Reintroduce the Dragon Egg Bedrock breaking bug from 1.12.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL emptyShulkerBoxStackAlways Empty Shulker Boxes will always stack, even inside inventories.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS, EXPERIMENTAL enderPearlChunkLoading Allow horizontally moving Ender Pearls to load chunks as entity ticking.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS fallingBlockDispensers Dispensers/Droppers with a block in front of them when powered will turn that block into a falling block\ndispenser \u0026amp; dropper give the same velocity to the falling block like they do in 22w13oneblockatatime\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, DISPENSER flowerPotChunkLoading Placing a wither rose in a flowerpot will load that chunk.\nIf u enable the rule the already existing chunks with flowerpots won\u0026rsquo;t be loaded.\nAlso disabling the carpet rule won\u0026rsquo;t remove the loaded chunks, u need to manually unload them using the /forceload command.\nAll the loaded chunks can be seen using /forceload query\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, EXPERIMENTAL hopperMinecart8gtCooldown Makes Hopper Minecarts have an 8gt cooldown like hoppers.\nType: Boolean Default value: false Allowed options: true, false Categories: BUGFIX, FEATURE, EXTRAS, EXPERIMENTAL hopperMinecartItemTransfer Allows Hopper Minecarts to transfer items into containers below them.\nType: Boolean Default value: false Allowed options: true, false Categories: BUGFIX, FEATURE, EXTRAS, EXPERIMENTAL maxSpongeRange Maximum offset limit for sponge.\nType: Integer Default value: 7 Suggested options: 7 Categories: FEATURE, EXTRAS maxSpongeSuck Maximum water sucking for sponge.\nType: Integer Default value: 64 Suggested options: 64 Categories: FEATURE, EXTRAS mobInFireConvertsSandToSoulsand If a living entity dies on sand with fire on top the sand will convert into soul sand.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE, EXPERIMENTAL pistonRedirectsRedstone Pistons and sticky pistons redirect redstone\nWhen retracting, they will blink visually\nbut that\u0026rsquo;s only to minimize changes required for it to work\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE reloadSuffocationFix Won\u0026rsquo;t let mobs glitch into blocks when reloaded.\nCan cause slight differences in mobs behaviour.\nFixes MC-2025.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, BUGFIX, EXPERIMENTAL renewableEndstone Dragon\u0026rsquo;s breath from dispensers convert cobblestone to end stone.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL, DISPENSER renewableIce Multiple ice crushed by falling anvils make denser ice.\nfrosted turns into normal, normal into packed and packed into blue\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL, FEATURE renewableNetherrack Fire charges from dispensers convert cobblestone to netherrack.\nCredits: Skyrising\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL renewableSand Cobblestone crushed by falling anvils makes sand.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, EXPERIMENTAL, FEATURE renewableWitherSkeletons Skeletons turn into wither skeletons when struck by lightning.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS repeaterPriorityFix Quick pulses won\u0026rsquo;t get lost in repeater setups.\nProbably brings back pre 1.8 behaviour.\nFixes MC-54711.\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, BUGFIX, EXPERIMENTAL scaffoldingDistance Max distance for scaffolding.\nType: Integer Default value: 7 Suggested options: 2, 3, 5, 7 Categories: FEATURE, EXTRAS Additional notes: You must choose a value from 0 to 7 spiderJockeysDropGapples Gives Spider jockeys a specified chance to drop enchanted golden apples.\n0 is the default setting, no enchanted golden apples will be dropped\nType: Integer Default value: 0 Suggested options: 0, 50, 100 Categories: EXTRAS, FEATURE Additional notes: You must choose a value from 0 to 100 straySpawningInIgloos Only strays spawn in igloos.\nType: Boolean Default value: false Allowed options: true, false Categories: FEATURE, EXTRAS variableWoodDelays Variable delays on wooden components (buttons, pressure plates).\nType: Boolean Default value: false Allowed options: true, false Categories: EXTRAS, FEATURE y0DragonEggBedrockBreaking Let dragon eggs break Y0 bedrock.\nRequires dragonEggBedrockBreaking to be set to true.\nType: Boolean Default value: false Allowed options: true, false Categories: EXPERIMENTAL, EXTRAS ","date":"2023-07-02T11:41:46+08:00","permalink":"http://xfrozenx.top/post/carpet-extra/","title":"Carpet Extra"},{"content":" 算法是一系列的计算步骤，用来将输入的数据转化成输出的结果。 特征： 有穷性 确定性 可行性 有零个或多个输入 至少有一个输出 描述方法： 自然语言\n流程图 1.\nflowchart TD id1([\u0026#34;起止框（表示算法开始和结束）\u0026#34;]) --\u0026gt;id2[\u0026#34;处理框（要处理的内容）\u0026#34;] --\u0026gt;id3[/\u0026#34;输入/输出框\u0026#34;/] --\u0026gt;id4{\u0026#34;判断框\u0026#34;} --\u0026gt;id5((\u0026#34;连接符\u0026#34;)) 伪代码\n基本控制结构 顺序结构\nflowchart TD A[\u0026#34;操作1\u0026#34;]--\u0026gt;B[\u0026#34;操作2\u0026#34;] 分支结构\nflowchart TD A[\u0026#34;操作1\u0026#34;]--\u0026gt;B{\u0026#34;条件\u0026#34;} B--\u0026gt;|是| C[\u0026#34;操作2\u0026#34;] B--\u0026gt;|否| D[\u0026#34;操作3\u0026#34;] C \u0026amp; D --\u0026gt;E[\u0026#34;分支外的操作\u0026#34;] 循环结构\n当循环\nflowchart TD A{\u0026#34;条件\u0026#34;} A--\u0026gt;|是| B[\u0026#34;循环体\u0026#34;] B--\u0026gt;A A---\u0026gt;|否| C[\u0026#34;循环外的操作\u0026#34;] 直到循环\nflowchart TD A[\u0026#34;循环体\u0026#34;]--\u0026gt;B{\u0026#34;条件\u0026#34;} B--\u0026gt;|否|A B--\u0026gt;|是|C[\u0026#34;循环外的操作\u0026#34;] ","date":"2023-06-15T22:55:55+08:00","permalink":"http://xfrozenx.top/post/%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","title":"算法的基本概念"},{"content":" 信息技术革命促使信息社会到来。\n农业社会—\u0026gt;工业社会—\u0026gt;信息社会\n信息社会是以信息活动为基础的社会。\n基本原则：以人为本、包容性、全面发展 资源：信息、知识 本质：以信息活动为基础 信息社会的特征：\n信息经济 指以信息与知识的生产、分配、拥有、使用为主要特征的经济形态。 是决定信息社会发展水平高低的最主要因素。 在线政务 指利用现代化信息技术实现社会管理和公共服务的新型政府治理模式。 特征：公开透明、高效治理、互动参与 数字生活 体现在生活工具、生活方式、生活内容的数字化。 网络社会 是信息社会最典型的特征。 信息系统\n是指在社会活动中，以满足信息需求为目标，以现代信息技术为手段，实现对信息有效采集和输入、传输、存储、处理、输出和利用而建立的包含人、硬件、软件、数据在内的综合系统。 要素：人、硬件、软件、数据 功能：信息的采集和输入、传输、存储、处理、输出和利用 ","date":"2023-05-29T22:20:08+08:00","permalink":"http://xfrozenx.top/post/hit-%E4%BF%A1%E6%81%AF%E6%8A%80%E6%9C%AF%E4%B8%8E%E7%A4%BE%E4%BC%9A/","title":"信息技术与社会"},{"content":"战术图：\n5人队伍，2人绿色，2人紫红色线路。\n绿色线路的任务是：\n香蕉道：木桶火、闪；用于骚扰。 回中路，补链接-包点隔断烟，准备提A1。 中路给包点闪 紫红色线路的任务是：\n侧道：vip火、中路烟（辅助绿色出中路） 清空锅炉房，等绿色到位。 烟囱闪，A1、A2同步。 ","date":"2023-05-27T19:13:20+08:00","permalink":"http://xfrozenx.top/post/inferno-t-a2%E6%A5%BC%E6%88%98%E6%9C%AF/","title":"Inferno T A2楼战术"},{"content":"#include\u0026lt;bits/stdc++.h\u0026gt; Inline math test When $ a \\neq 0 $, we can find $$ x=\\frac{-b\\pm\\sqrt{b^2-4ac}}{2a} $$ helloworld123456789 你好\n","date":"2023-05-25T22:36:21+08:00","permalink":"http://xfrozenx.top/post/hello_world/","title":"Hello_world"}]